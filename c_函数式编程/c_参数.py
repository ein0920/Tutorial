
# 函数引用外部变量
if __name__ == '__main__':
    # 可以调用外部变量
    a = 1
    def add_a():
        print(a)
    add_a()

    # 但是不能改变外部变量的地址
    b = 2
    def add_b():
        b += 1
        print(b)

    # 这个时候要申明b
    b = 1
    def add_b_1():
        global b
        b += 1
        print(b)
    add_b_1()

    # 如果外部变量可变，则可改变内容
    c = []
    def append_c():
        c.append(1)
        print(c)
    append_c()
    '''
    第一，两者的功能不同。
    global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，
    而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，
    如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。

    第二，两者使用的范围不同。
    global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，
    即使之前未定义该变量，global修饰后也可以直接使用，
    而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误（见第一）。

    '''

# -------------------------------------------改变传入参数的值------------------------------------------------------------
if __name__ == '__main__':
    # 传入参数的地址可以改变
    def change_a(a):
        a +=1
        print(a)

    change_a(4)

# -------------------------------------------默认参数可变出错的情况
if __name__ == '__main__':
    def spam(b=[]):
        return b

    a = spam()  # 先运行一次，
    print(a)
    a.append(1)
    a.append(2)
    b = spam()  # 第二次运行会受到第一次的影响
    print(b)  # Carefully observe result
    print('-' * 10)


# 默认参数可变出错的情况2
if __name__ == '__main__':
    def add_end(L=[]):
        L.append('END')
        return L

    # 正常调用时，不会有问题
    add_end([1, 2, 3])
    add_end(['x', 'y', 'z'])

    # 这时候出问题了
    add_end()
    add_end()
    '''
    Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，
    因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，
    如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。
    '''


